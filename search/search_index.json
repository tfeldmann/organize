{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to organize's documentation # organize - The file management automation tool Full documentation at Read the docs organize v2 is released! # This is a huge update with lots of improvements. Please backup all your important stuff before running and use the simulate option! See the changelog for all the new features! Migration guide from organize v1 About # Your desktop is a mess? You cannot find anything in your downloads and documents? Sorting and renaming all these files by hand is too tedious? Time to automate it once and benefit from it forever. organize is a command line, open-source alternative to apps like Hazel (macOS) or File Juggler (Windows). Features # Some highlights include: Free and open source. Please donate if it is useful for you! Works on macOS, Windows and Linux Safe moving, renaming, copying of files and folders with conflict resolution options Fast duplicate file detection Exif tags extraction Categorization via text extracted from PDF, DOCX and many more Supports remote file locations like FTP, WebDAV, S3 Buckets, SSH and many more Powerful template engine Inline python and shell commands as filters and actions for maximum flexibility Everything can be simulated before touching your files. Getting started # Installation # organize works on macOS, Windows and Linux. Only python 3.6+ is needed. Install it via your package manager or from python.org . Installation is done via pip. Note that the package name is organize-tool : pip3 install -U organize-tool If you want the text extraction capabilities, install with textract like this: pip3 install -U \"organize-tool[textract]\" This command can also be used to update to the newest version. Now you can run organize --help to check if the installation was successful. Create your first rule # In your shell, run organize edit to edit the configuration: rules: - name: \"Find PDFs\" locations: - ~/Downloads subfolders: true filters: - extension: pdf actions: - echo: \"Found PDF!\" If you have problems editing the configuration you can run organize reveal to reveal the configuration folder in your file manager. You can then edit the config.yaml in your favourite editor. save your config file and run: organize run You will see a list of all .pdf files you have in your downloads folder (+ subfolders). For now we only show the text Found PDF! for each file, but this will change soon... (If it shows Nothing to do you simply don't have any pdfs in your downloads folder). Run organize edit again and add a move -action to your rule: actions: - echo: \"Found PDF!\" - move: ~/Documents/PDFs/ Now run organize sim to see what would happen without touching your files. You will see that your pdf-files would be moved over to your Documents/PDFs folder. Congratulations, you just automated your first task. You can now run organize run whenever you like and all your pdfs are a bit more organized. It's that easy. There is so much more. You want to rename / copy files, run custom shell- or python scripts, match names with regular expressions or use placeholder variables? organize has you covered. Have a look at the advanced usage example below! Example rules # Here are some examples of simple organization and cleanup rules. Modify to your needs! Move all invoices, orders or purchase documents into your documents folder: rules: - name: \"Sort my invoices and receipts\" locations: ~/Downloads subfolders: true filters: - extension: pdf - name: contains: - Invoice - Order - Purchase case_sensitive: false actions: - move: ~/Documents/Shopping/ Recursively delete all empty directories: rules: - name: \"Recursively delete all empty directories\" locations: - path: ~/Downloads subfolders: true filters: - empty actions: - delete You'll find many more examples in the full documentation . Command line interface # Usage: organize [OPTIONS] COMMAND [ARGS]... organize The file management automation tool. Options: --version Show the version and exit. -h, --help Show this message and exit. Commands: run Organizes your files according to your rules. sim Simulates a run (does not touch your files). edit Edit the rules. check Checks whether a given config file is valid. reveal Reveals the default config file. schema Prints the json schema for config files. docs Opens the documentation. Other donation options: # ETH: 0x0C0EF9e121e105dbFEfd1CF1f6a0C1588c839B13 BTC: 3PfHR44kUUGXNV5pvRTEBpNgcKPx7byjop","title":"Home"},{"location":"#welcome-to-organizes-documentation","text":"organize - The file management automation tool Full documentation at Read the docs","title":"Welcome to organize's documentation"},{"location":"#organize-v2-is-released","text":"This is a huge update with lots of improvements. Please backup all your important stuff before running and use the simulate option! See the changelog for all the new features! Migration guide from organize v1","title":"organize v2 is released!"},{"location":"#about","text":"Your desktop is a mess? You cannot find anything in your downloads and documents? Sorting and renaming all these files by hand is too tedious? Time to automate it once and benefit from it forever. organize is a command line, open-source alternative to apps like Hazel (macOS) or File Juggler (Windows).","title":"About"},{"location":"#features","text":"Some highlights include: Free and open source. Please donate if it is useful for you! Works on macOS, Windows and Linux Safe moving, renaming, copying of files and folders with conflict resolution options Fast duplicate file detection Exif tags extraction Categorization via text extracted from PDF, DOCX and many more Supports remote file locations like FTP, WebDAV, S3 Buckets, SSH and many more Powerful template engine Inline python and shell commands as filters and actions for maximum flexibility Everything can be simulated before touching your files.","title":"Features"},{"location":"#getting-started","text":"","title":"Getting started"},{"location":"#installation","text":"organize works on macOS, Windows and Linux. Only python 3.6+ is needed. Install it via your package manager or from python.org . Installation is done via pip. Note that the package name is organize-tool : pip3 install -U organize-tool If you want the text extraction capabilities, install with textract like this: pip3 install -U \"organize-tool[textract]\" This command can also be used to update to the newest version. Now you can run organize --help to check if the installation was successful.","title":"Installation"},{"location":"#create-your-first-rule","text":"In your shell, run organize edit to edit the configuration: rules: - name: \"Find PDFs\" locations: - ~/Downloads subfolders: true filters: - extension: pdf actions: - echo: \"Found PDF!\" If you have problems editing the configuration you can run organize reveal to reveal the configuration folder in your file manager. You can then edit the config.yaml in your favourite editor. save your config file and run: organize run You will see a list of all .pdf files you have in your downloads folder (+ subfolders). For now we only show the text Found PDF! for each file, but this will change soon... (If it shows Nothing to do you simply don't have any pdfs in your downloads folder). Run organize edit again and add a move -action to your rule: actions: - echo: \"Found PDF!\" - move: ~/Documents/PDFs/ Now run organize sim to see what would happen without touching your files. You will see that your pdf-files would be moved over to your Documents/PDFs folder. Congratulations, you just automated your first task. You can now run organize run whenever you like and all your pdfs are a bit more organized. It's that easy. There is so much more. You want to rename / copy files, run custom shell- or python scripts, match names with regular expressions or use placeholder variables? organize has you covered. Have a look at the advanced usage example below!","title":"Create your first rule"},{"location":"#example-rules","text":"Here are some examples of simple organization and cleanup rules. Modify to your needs! Move all invoices, orders or purchase documents into your documents folder: rules: - name: \"Sort my invoices and receipts\" locations: ~/Downloads subfolders: true filters: - extension: pdf - name: contains: - Invoice - Order - Purchase case_sensitive: false actions: - move: ~/Documents/Shopping/ Recursively delete all empty directories: rules: - name: \"Recursively delete all empty directories\" locations: - path: ~/Downloads subfolders: true filters: - empty actions: - delete You'll find many more examples in the full documentation .","title":"Example rules"},{"location":"#command-line-interface","text":"Usage: organize [OPTIONS] COMMAND [ARGS]... organize The file management automation tool. Options: --version Show the version and exit. -h, --help Show this message and exit. Commands: run Organizes your files according to your rules. sim Simulates a run (does not touch your files). edit Edit the rules. check Checks whether a given config file is valid. reveal Reveals the default config file. schema Prints the json schema for config files. docs Opens the documentation.","title":"Command line interface"},{"location":"#other-donation-options","text":"ETH: 0x0C0EF9e121e105dbFEfd1CF1f6a0C1588c839B13 BTC: 3PfHR44kUUGXNV5pvRTEBpNgcKPx7byjop","title":"Other donation options:"},{"location":"actions/","text":"Actions # This page shows the specifics of each action. For basic action usage and options have a look at the Rules section. confirm # Ask for confirmation before continuing. Examples Confirm before deleting a duplicate rules: - name: \"Delete duplicates with confirmation\" locations: - ~/Downloads - ~/Documents filters: - not empty - duplicate - name actions: - confirm: \"Delete {name}?\" - trash copy # Copy a file or dir to a new location. If the specified path does not exist it will be created. Parameters: dest ( str ) \u2013 The destination where the file / dir should be copied to. If dest ends with a slash, it is assumed to be a target directory and the file / dir will be copied into dest and keep its name. on_conflict ( str ) \u2013 What should happen in case dest already exists. One of skip , overwrite , trash , rename_new and rename_existing . Defaults to rename_new . rename_template ( str ) \u2013 A template for renaming the file / dir in case of a conflict. Defaults to {name} {counter}{extension} . filesystem ( str ) \u2013 (Optional) A pyfilesystem opener url of the filesystem you want to copy to. If this is not given, the local filesystem is used. The next action will work with the created copy. Examples: Copy all pdfs into ~/Desktop/somefolder/ and keep filenames rules: - locations: ~/Desktop filters: - extension: pdf actions: - copy: \"~/Desktop/somefolder/\" Use a placeholder to copy all .pdf files into a \"PDF\" folder and all .jpg files into a \"JPG\" folder. Existing files will be overwritten. rules: - locations: ~/Desktop filters: - extension: - pdf - jpg actions: - copy: dest: \"~/Desktop/{extension.upper()}/\" on_conflict: overwrite Copy into the folder Invoices . Keep the filename but do not overwrite existing files. To prevent overwriting files, an index is added to the filename, so somefile.jpg becomes somefile 2.jpg . The counter separator is ' ' by default, but can be changed using the counter_separator property. rules: - locations: ~/Desktop/Invoices filters: - extension: - pdf actions: - copy: dest: \"~/Documents/Invoices/\" on_conflict: \"rename_new\" rename_template: \"{name} {counter}{extension}\" delete # Delete a file from disk. Deleted files have no recovery option! Using the Trash action is strongly advised for most use-cases! Examples: Delete old downloads. rules: - locations: \"~/Downloads\" filters: - lastmodified: days: 365 - extension: - png - jpg actions: - delete Delete all empty subfolders rules: - name: Delete all empty subfolders locations: - path: \"~/Downloads\" max_depth: null targets: dirs filters: - empty actions: - delete echo # Prints the given message. This can be useful to test your rules, especially in combination with placeholder variables. Parameters: msg ( str ) \u2013 The message to print. Accepts placeholder variables. Examples: rules: - name: \"Find files older than a year\" locations: ~/Desktop filters: - lastmodified: days: 365 actions: - echo: \"Found old file\" Prints \"Hello World!\" and filepath for each file on the desktop: rules: - locations: - ~/Desktop actions: - echo: \"Hello World! {path}\" This will print something like Found a ZIP: \"backup\" for each file on your desktop rules: - locations: - ~/Desktop filters: - extension - name actions: - echo: 'Found a {extension.upper()}: \"{name}\"' Show the {relative_path} and {path} of all files in '~/Downloads', '~/Desktop' and their subfolders: rules: - locations: - path: ~/Desktop max_depth: null - path: ~/Downloads max_depth: null actions: - echo: \"Path: {path}\" - echo: \"Relative: {relative_path}\" macos_tags # Add macOS tags. Parameters: *tags ( str ) \u2013 A list of tags or a single tag. The color can be specified in brackets after the tag name, for example: macos_tags: \"Invoices (red)\" Available colors are none , gray , green , purple , blue , yellow , red and orange . Examples: rules: - name: \"add a single tag\" locations: \"~/Documents/Invoices\" filters: - name: startswith: \"Invoice\" - extension: pdf actions: - macos_tags: Invoice Adding multiple tags (\"Invoice\" and \"Important\") rules: - locations: \"~/Documents/Invoices\" filters: - name: startswith: \"Invoice\" - extension: pdf actions: - macos_tags: - Important - Invoice Specify tag colors rules: - locations: \"~/Documents/Invoices\" filters: - name: startswith: \"Invoice\" - extension: pdf actions: - macos_tags: - Important (green) - Invoice (purple) Add a templated tag with color rules: - locations: \"~/Documents/Invoices\" filters: - created actions: - macos_tags: - Year-{created.year} (red) move # Move a file to a new location. The file can also be renamed. If the specified path does not exist it will be created. If you only want to rename the file and keep the folder, it is easier to use the rename action. Parameters: dest ( str ) \u2013 The destination where the file / dir should be moved to. If dest ends with a slash, it is assumed to be a target directory and the file / dir will be moved into dest and keep its name. on_conflict ( str ) \u2013 What should happen in case dest already exists. One of skip , overwrite , trash , rename_new and rename_existing . Defaults to rename_new . rename_template ( str ) \u2013 A template for renaming the file / dir in case of a conflict. Defaults to {name} {counter}{extension} . filesystem ( str ) \u2013 (Optional) A pyfilesystem opener url of the filesystem you want to copy to. If this is not given, the local filesystem is used. The next action will work with the moved file / dir. Examples: Move all pdfs and jpgs from the desktop into the folder \"~/Desktop/media/\". Filenames are not changed. rules: - locations: ~/Desktop filters: - extension: - pdf - jpg actions: - move: \"~/Desktop/media/\" Use a placeholder to move all .pdf files into a \"PDF\" folder and all .jpg files into a \"JPG\" folder. Existing files will be overwritten. rules: - locations: ~/Desktop filters: - extension: - pdf - jpg actions: - move: dest: \"~/Desktop/{extension.upper()}/\" on_conflict: \"overwrite\" Move pdfs into the folder Invoices . Keep the filename but do not overwrite existing files. To prevent overwriting files, an index is added to the filename, so somefile.jpg becomes somefile 2.jpg . rules: - locations: ~/Desktop/Invoices filters: - extension: - pdf actions: - move: dest: \"~/Documents/Invoices/\" on_conflict: \"rename_new\" rename_template: \"{name} {counter}{extension}\" python # Execute python code. Parameters: code ( str ) \u2013 The python code to execute. run_in_simulation ( bool ) \u2013 Whether to execute this code in simulation mode (Default false). Examples: A basic example that shows how to get the current file path and do some printing in a for loop. The | is yaml syntax for defining a string literal spanning multiple lines. rules: - locations: \"~/Desktop\" actions: - python: | print('The path of the current file is %s' % path) for _ in range(5): print('Heyho, its me from the loop') rules: - name: \"You can access filter data\" locations: ~/Desktop filters: - regex: '^(?P<name>.*)\\.(?P<extension>.*)$' actions: - python: | print('Name: %s' % regex[\"name\"]) print('Extension: %s' % regex[\"extension\"]) Running in simulation and yaml aliases : my_python_script: &script | print(\"Hello World!\") print(path) rules: - name: \"Run in simulation and yaml alias\" locations: - ~/Desktop/ actions: - python: code: *script run_in_simulation: yes You have access to all the python magic -- do a google search for each filename starting with an underscore: rules: - locations: ~/Desktop filters: - name: startswith: \"_\" actions: - python: | import webbrowser webbrowser.open('https://www.google.com/search?q=%s' % name) rename # Renames a file. Parameters: name ( str ) \u2013 The new name for the file / dir. on_conflict ( str ) \u2013 What should happen in case dest already exists. One of skip , overwrite , trash , rename_new and rename_existing . Defaults to rename_new . rename_template ( str ) \u2013 A template for renaming the file / dir in case of a conflict. Defaults to {name} {counter}{extension} . The next action will work with the renamed file / dir. Examples: rules: - name: \"Convert all .PDF file extensions to lowercase (.pdf)\" locations: \"~/Desktop\" filters: - name - extension: PDF actions: - rename: \"{name}.pdf\" rules: - name: \"Convert **all** file extensions to lowercase\" locations: \"~/Desktop\" filters: - name - extension actions: - rename: \"{name}.{extension.lower()}\" shell # Executes a shell command Parameters: cmd ( str ) \u2013 The command to execute. run_in_simulation ( bool ) \u2013 Whether to execute in simulation mode (default = false) ignore_errors ( bool ) \u2013 Whether to continue on returncodes != 0. simulation_output ( str ) \u2013 The value of {shell.output} if run in simulation simulation_returncode ( int ) \u2013 The value of {shell.returncode} if run in simulation Returns {shell.output} ( str ): The stdout of the executed process. {shell.returncode} ( int ): The returncode of the executed process. Examples: rules: - name: \"On macOS: Open all pdfs on your desktop\" locations: \"~/Desktop\" filters: - extension: pdf actions: - shell: 'open \"{path}\"' symlink # Create a symbolic link. Parameters: dest ( str ) \u2013 The symlink destination. If dest ends with a slash `/``, create the symlink in the given directory. Can contain placeholders. Only the local filesystem is supported. trash # Move a file or dir into the trash. Examples: rules: - name: Move all JPGs and PNGs on the desktop which are older than one year into the trash locations: \"~/Desktop\" filters: - lastmodified: years: 1 mode: older - extension: - png - jpg actions: - trash","title":"Actions"},{"location":"actions/#actions","text":"This page shows the specifics of each action. For basic action usage and options have a look at the Rules section.","title":"Actions"},{"location":"actions/#confirm","text":"Ask for confirmation before continuing. Examples Confirm before deleting a duplicate rules: - name: \"Delete duplicates with confirmation\" locations: - ~/Downloads - ~/Documents filters: - not empty - duplicate - name actions: - confirm: \"Delete {name}?\" - trash","title":"confirm"},{"location":"actions/#copy","text":"Copy a file or dir to a new location. If the specified path does not exist it will be created. Parameters: dest ( str ) \u2013 The destination where the file / dir should be copied to. If dest ends with a slash, it is assumed to be a target directory and the file / dir will be copied into dest and keep its name. on_conflict ( str ) \u2013 What should happen in case dest already exists. One of skip , overwrite , trash , rename_new and rename_existing . Defaults to rename_new . rename_template ( str ) \u2013 A template for renaming the file / dir in case of a conflict. Defaults to {name} {counter}{extension} . filesystem ( str ) \u2013 (Optional) A pyfilesystem opener url of the filesystem you want to copy to. If this is not given, the local filesystem is used. The next action will work with the created copy. Examples: Copy all pdfs into ~/Desktop/somefolder/ and keep filenames rules: - locations: ~/Desktop filters: - extension: pdf actions: - copy: \"~/Desktop/somefolder/\" Use a placeholder to copy all .pdf files into a \"PDF\" folder and all .jpg files into a \"JPG\" folder. Existing files will be overwritten. rules: - locations: ~/Desktop filters: - extension: - pdf - jpg actions: - copy: dest: \"~/Desktop/{extension.upper()}/\" on_conflict: overwrite Copy into the folder Invoices . Keep the filename but do not overwrite existing files. To prevent overwriting files, an index is added to the filename, so somefile.jpg becomes somefile 2.jpg . The counter separator is ' ' by default, but can be changed using the counter_separator property. rules: - locations: ~/Desktop/Invoices filters: - extension: - pdf actions: - copy: dest: \"~/Documents/Invoices/\" on_conflict: \"rename_new\" rename_template: \"{name} {counter}{extension}\"","title":"copy"},{"location":"actions/#delete","text":"Delete a file from disk. Deleted files have no recovery option! Using the Trash action is strongly advised for most use-cases! Examples: Delete old downloads. rules: - locations: \"~/Downloads\" filters: - lastmodified: days: 365 - extension: - png - jpg actions: - delete Delete all empty subfolders rules: - name: Delete all empty subfolders locations: - path: \"~/Downloads\" max_depth: null targets: dirs filters: - empty actions: - delete","title":"delete"},{"location":"actions/#echo","text":"Prints the given message. This can be useful to test your rules, especially in combination with placeholder variables. Parameters: msg ( str ) \u2013 The message to print. Accepts placeholder variables. Examples: rules: - name: \"Find files older than a year\" locations: ~/Desktop filters: - lastmodified: days: 365 actions: - echo: \"Found old file\" Prints \"Hello World!\" and filepath for each file on the desktop: rules: - locations: - ~/Desktop actions: - echo: \"Hello World! {path}\" This will print something like Found a ZIP: \"backup\" for each file on your desktop rules: - locations: - ~/Desktop filters: - extension - name actions: - echo: 'Found a {extension.upper()}: \"{name}\"' Show the {relative_path} and {path} of all files in '~/Downloads', '~/Desktop' and their subfolders: rules: - locations: - path: ~/Desktop max_depth: null - path: ~/Downloads max_depth: null actions: - echo: \"Path: {path}\" - echo: \"Relative: {relative_path}\"","title":"echo"},{"location":"actions/#macos_tags","text":"Add macOS tags. Parameters: *tags ( str ) \u2013 A list of tags or a single tag. The color can be specified in brackets after the tag name, for example: macos_tags: \"Invoices (red)\" Available colors are none , gray , green , purple , blue , yellow , red and orange . Examples: rules: - name: \"add a single tag\" locations: \"~/Documents/Invoices\" filters: - name: startswith: \"Invoice\" - extension: pdf actions: - macos_tags: Invoice Adding multiple tags (\"Invoice\" and \"Important\") rules: - locations: \"~/Documents/Invoices\" filters: - name: startswith: \"Invoice\" - extension: pdf actions: - macos_tags: - Important - Invoice Specify tag colors rules: - locations: \"~/Documents/Invoices\" filters: - name: startswith: \"Invoice\" - extension: pdf actions: - macos_tags: - Important (green) - Invoice (purple) Add a templated tag with color rules: - locations: \"~/Documents/Invoices\" filters: - created actions: - macos_tags: - Year-{created.year} (red)","title":"macos_tags"},{"location":"actions/#move","text":"Move a file to a new location. The file can also be renamed. If the specified path does not exist it will be created. If you only want to rename the file and keep the folder, it is easier to use the rename action. Parameters: dest ( str ) \u2013 The destination where the file / dir should be moved to. If dest ends with a slash, it is assumed to be a target directory and the file / dir will be moved into dest and keep its name. on_conflict ( str ) \u2013 What should happen in case dest already exists. One of skip , overwrite , trash , rename_new and rename_existing . Defaults to rename_new . rename_template ( str ) \u2013 A template for renaming the file / dir in case of a conflict. Defaults to {name} {counter}{extension} . filesystem ( str ) \u2013 (Optional) A pyfilesystem opener url of the filesystem you want to copy to. If this is not given, the local filesystem is used. The next action will work with the moved file / dir. Examples: Move all pdfs and jpgs from the desktop into the folder \"~/Desktop/media/\". Filenames are not changed. rules: - locations: ~/Desktop filters: - extension: - pdf - jpg actions: - move: \"~/Desktop/media/\" Use a placeholder to move all .pdf files into a \"PDF\" folder and all .jpg files into a \"JPG\" folder. Existing files will be overwritten. rules: - locations: ~/Desktop filters: - extension: - pdf - jpg actions: - move: dest: \"~/Desktop/{extension.upper()}/\" on_conflict: \"overwrite\" Move pdfs into the folder Invoices . Keep the filename but do not overwrite existing files. To prevent overwriting files, an index is added to the filename, so somefile.jpg becomes somefile 2.jpg . rules: - locations: ~/Desktop/Invoices filters: - extension: - pdf actions: - move: dest: \"~/Documents/Invoices/\" on_conflict: \"rename_new\" rename_template: \"{name} {counter}{extension}\"","title":"move"},{"location":"actions/#python","text":"Execute python code. Parameters: code ( str ) \u2013 The python code to execute. run_in_simulation ( bool ) \u2013 Whether to execute this code in simulation mode (Default false). Examples: A basic example that shows how to get the current file path and do some printing in a for loop. The | is yaml syntax for defining a string literal spanning multiple lines. rules: - locations: \"~/Desktop\" actions: - python: | print('The path of the current file is %s' % path) for _ in range(5): print('Heyho, its me from the loop') rules: - name: \"You can access filter data\" locations: ~/Desktop filters: - regex: '^(?P<name>.*)\\.(?P<extension>.*)$' actions: - python: | print('Name: %s' % regex[\"name\"]) print('Extension: %s' % regex[\"extension\"]) Running in simulation and yaml aliases : my_python_script: &script | print(\"Hello World!\") print(path) rules: - name: \"Run in simulation and yaml alias\" locations: - ~/Desktop/ actions: - python: code: *script run_in_simulation: yes You have access to all the python magic -- do a google search for each filename starting with an underscore: rules: - locations: ~/Desktop filters: - name: startswith: \"_\" actions: - python: | import webbrowser webbrowser.open('https://www.google.com/search?q=%s' % name)","title":"python"},{"location":"actions/#rename","text":"Renames a file. Parameters: name ( str ) \u2013 The new name for the file / dir. on_conflict ( str ) \u2013 What should happen in case dest already exists. One of skip , overwrite , trash , rename_new and rename_existing . Defaults to rename_new . rename_template ( str ) \u2013 A template for renaming the file / dir in case of a conflict. Defaults to {name} {counter}{extension} . The next action will work with the renamed file / dir. Examples: rules: - name: \"Convert all .PDF file extensions to lowercase (.pdf)\" locations: \"~/Desktop\" filters: - name - extension: PDF actions: - rename: \"{name}.pdf\" rules: - name: \"Convert **all** file extensions to lowercase\" locations: \"~/Desktop\" filters: - name - extension actions: - rename: \"{name}.{extension.lower()}\"","title":"rename"},{"location":"actions/#shell","text":"Executes a shell command Parameters: cmd ( str ) \u2013 The command to execute. run_in_simulation ( bool ) \u2013 Whether to execute in simulation mode (default = false) ignore_errors ( bool ) \u2013 Whether to continue on returncodes != 0. simulation_output ( str ) \u2013 The value of {shell.output} if run in simulation simulation_returncode ( int ) \u2013 The value of {shell.returncode} if run in simulation Returns {shell.output} ( str ): The stdout of the executed process. {shell.returncode} ( int ): The returncode of the executed process. Examples: rules: - name: \"On macOS: Open all pdfs on your desktop\" locations: \"~/Desktop\" filters: - extension: pdf actions: - shell: 'open \"{path}\"'","title":"shell"},{"location":"actions/#symlink","text":"Create a symbolic link. Parameters: dest ( str ) \u2013 The symlink destination. If dest ends with a slash `/``, create the symlink in the given directory. Can contain placeholders. Only the local filesystem is supported.","title":"symlink"},{"location":"actions/#trash","text":"Move a file or dir into the trash. Examples: rules: - name: Move all JPGs and PNGs on the desktop which are older than one year into the trash locations: \"~/Desktop\" filters: - lastmodified: years: 1 mode: older - extension: - png - jpg actions: - trash","title":"trash"},{"location":"changelog/","text":"Changelog # v2.0.9 (2022-02-10) # shell shows a message when code is not run in simulation shell add options simulation_output and simulation_returncode fixes a bug where location options are applied to other locations as well created filter now falls back to using the stat utility on linux systems where the birthtime is not included in os.stat . v2.0.8 (2022-02-09) # Bugfix shell for real. v2.0.7 (2022-02-09) # Bugfix for shell . v2.0.6 (2022-02-09) # Speed up moving files. shell action: Run command through the user's shell. v2.0.5 (2022-02-08) # Fixed the migration message and docs URL v2.0.4 (2022-02-08) # exclude_dir, system_exclude_dirs, exclude_files, system_exclude_files, filter and filter_dirs now accept single strings. Fixed a bug in the name filter v2.0.3 (2022-02-07) # Fixed typo: system_exlude_files v2.0.2 (2022-02-07) # Bugfix in env variable expansion in locations v2.0.1 (2022-02-07) # Small bugfix in macos_tags action. Bugfix in the migration detection. v2.0.0 (2022-02-07) # This is a huge update with lots of improvements. Please backup all your important stuff before running and use the simulate option! Migration Guide what's new # You can now target directories with your rules (copying, renaming, etc a whole folder) Organize inside or between (S)FTP, S3 Buckets, Zip archives and many more (list of available filesystems ). max_depth setting when recursing into subfolders Respects your rule order - safer, less magic, less surprises. (organize v1 tried to be clever. v2 now works your config file from top to bottom) Jinja2 template engine for placeholders . Instant start. (does not need to gather all the files before starting) Filters can now be excluded . Filter modes : all , any and none . Rule names . new conflict resolution settings in move , copy and rename action: Options are skip , overwrite , trash , rename_new or rename_existing You can now define a custom rename_template . The duplicate now supports several options on how to distinguish between original and duplicate file. The python action can now be run in simulation. The shell action now returns stdout and errorcode. Added filter empty - find empty files and folders Added filter hash - generate file hashes Added action symlink - generate symlinks Added action confirm - asks for confirmation Many small fixes and improvements! changed # The timezone keyword for lastmodified and created was removed. The timezone is now the local timezone by default. The filesize filter was renamed to size and can now be used to get directory sizes as well. The filename filter was renamed to name and can now be used to get directory names as well. The size filter now returns multiple formats removed # Glob syntax is gone from folders ( no longer needed ) \"!\" folder exclude syntax is gone ( no longer needed ) v1.10.1 (2021-04-21) # Action macos_tags now supports colors and placeholders. Show full expanded path if folder is not found. v1.10.0 (2021-04-20) # Add filter mimetype Add action macos_tags Support simplematch syntax in lename -filter. Updated dependencies Because installing textract is quite hard on some platforms it is now an optional dendency. Install it with pip install organize-tool[textract] This version needs python 3.6 minimum. Some dependencies that were simply backports (thlib2, typing) are removed. Add timezones in created and last_modified filters (Thank you, @win0err!) v1.9.1 (2020-11-10) # Add {env} variable Add {now} variable v1.9 (2020-06-12) # Add filter Duplicate . v1.8.2 (2020-04-03) # Fix a bug in the filename filter config parsing algorithm with digits-only filenames. v1.8.1 (2020-03-28) # Flatten filter and action lists to allow enhanced config file configuration (Thanks to @rawdamedia!) Add support for multiline content filters (Thanks to @zor-el!) v1.8.0 (2020-03-04) # Added action Delete . Added filter FileContent . Python 3.4 is officially deprecated and no longer supported. --config-file command line option now supports ~ for user folder and expansion oenvironment variables Added years , months , weeks and seconds parameter to filter created and stmodified v1.7.0 (2019-11-26) # Added filter Exif to filter by image exif data. Placeholder variable properties are now case insensitve. v1.6.2 (2019-11-22) # Fix Rename action ( 'PosixPath' object has no attribute 'items' ). Use type hints everywhere. v1.6.1 (2019-10-25) # Shows a warning for missing folders instead of raising an exception. v1.6 (2019-08-19) # Added filter: Python Added filter: FileSize The organize module can now be run directly: python3 -m organize Various code simplifications and speedups. Fixes an issue with globstring file exclusion. Remove clint dependency as it is no longer maintained. Added various integration tests The \"~~ SIMULATION ~~\"-banner now takes up the whole terminal width v1.5.3 (2019-08-01) # Filename filter now supports lists. v1.5.2 (2019-07-29) # Environment variables in folder pathes are now expanded (syntax $name or ${name} a additionally %name% on windows). F example this allows the usage of e.g. %public/Desktop% in windows. v1.5.1 (2019-07-23) # New filter \"Created\" to filter by creation date. Fixes issue #39 where globstrings don't work most of the time. Integration test for issue #39 Support indented config files v1.5 (2019-07-17) # Fixes issue #31 where the {path} variable always resolves to the source path Updated dependencies Exclude changelog and readme from published wheel v1.4.5 (2019-07-03) # Filter and Actions names are now case-insensitive v1.4.4 (2019-07-02) # Fixes issues #36 with umlauts in config file on windows v1.4.3 (2019-06-05) # Use safe YAML loader to fix a deprecation warning. (Thanks mope1!) Better error message if a folder does not exist. (Again thanks mope1!) Fix example code in documentation for LastModified filter. Custom config file locations (given by cmd line argument or environment variable). config --debug now shows the full path to the config file. v1.4.2 (2018-11-14) # Fixes a bug with command line arguments in the $EDITOR environment viable. Fixes a bug where an empty config wouldn't show the correct error message. Fix binary wheel creation in setup.py by using environment markers v1.4.1 (2018-10-05) # A custom separator counter_separator can now be set in the actions Move, Cy and Rename. v1.4 (2018-09-21) # Fixes a bug where glob wildcards are not detected correctly Adds support for excluding folders and files via glob syntax. Makes sure that files are only handled once per rule. v1.3 (2018-07-06) # Glob support in folder configuration. New variable {relative_path} is now available in actions. v1.2 (2018-03-19) # Shows the relative path to files in subfolders. v1.1 (2018-03-13) # Removes the colon from extension filter output so {extension.lower} now rurns 'png' instead of '.png' . v1.0 (2018-03-13) # Initial release.","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#v209-2022-02-10","text":"shell shows a message when code is not run in simulation shell add options simulation_output and simulation_returncode fixes a bug where location options are applied to other locations as well created filter now falls back to using the stat utility on linux systems where the birthtime is not included in os.stat .","title":"v2.0.9 (2022-02-10)"},{"location":"changelog/#v208-2022-02-09","text":"Bugfix shell for real.","title":"v2.0.8 (2022-02-09)"},{"location":"changelog/#v207-2022-02-09","text":"Bugfix for shell .","title":"v2.0.7 (2022-02-09)"},{"location":"changelog/#v206-2022-02-09","text":"Speed up moving files. shell action: Run command through the user's shell.","title":"v2.0.6 (2022-02-09)"},{"location":"changelog/#v205-2022-02-08","text":"Fixed the migration message and docs URL","title":"v2.0.5 (2022-02-08)"},{"location":"changelog/#v204-2022-02-08","text":"exclude_dir, system_exclude_dirs, exclude_files, system_exclude_files, filter and filter_dirs now accept single strings. Fixed a bug in the name filter","title":"v2.0.4 (2022-02-08)"},{"location":"changelog/#v203-2022-02-07","text":"Fixed typo: system_exlude_files","title":"v2.0.3 (2022-02-07)"},{"location":"changelog/#v202-2022-02-07","text":"Bugfix in env variable expansion in locations","title":"v2.0.2 (2022-02-07)"},{"location":"changelog/#v201-2022-02-07","text":"Small bugfix in macos_tags action. Bugfix in the migration detection.","title":"v2.0.1 (2022-02-07)"},{"location":"changelog/#v200-2022-02-07","text":"This is a huge update with lots of improvements. Please backup all your important stuff before running and use the simulate option! Migration Guide","title":"v2.0.0 (2022-02-07)"},{"location":"changelog/#whats-new","text":"You can now target directories with your rules (copying, renaming, etc a whole folder) Organize inside or between (S)FTP, S3 Buckets, Zip archives and many more (list of available filesystems ). max_depth setting when recursing into subfolders Respects your rule order - safer, less magic, less surprises. (organize v1 tried to be clever. v2 now works your config file from top to bottom) Jinja2 template engine for placeholders . Instant start. (does not need to gather all the files before starting) Filters can now be excluded . Filter modes : all , any and none . Rule names . new conflict resolution settings in move , copy and rename action: Options are skip , overwrite , trash , rename_new or rename_existing You can now define a custom rename_template . The duplicate now supports several options on how to distinguish between original and duplicate file. The python action can now be run in simulation. The shell action now returns stdout and errorcode. Added filter empty - find empty files and folders Added filter hash - generate file hashes Added action symlink - generate symlinks Added action confirm - asks for confirmation Many small fixes and improvements!","title":"what's new"},{"location":"changelog/#changed","text":"The timezone keyword for lastmodified and created was removed. The timezone is now the local timezone by default. The filesize filter was renamed to size and can now be used to get directory sizes as well. The filename filter was renamed to name and can now be used to get directory names as well. The size filter now returns multiple formats","title":"changed"},{"location":"changelog/#removed","text":"Glob syntax is gone from folders ( no longer needed ) \"!\" folder exclude syntax is gone ( no longer needed )","title":"removed"},{"location":"changelog/#v1101-2021-04-21","text":"Action macos_tags now supports colors and placeholders. Show full expanded path if folder is not found.","title":"v1.10.1 (2021-04-21)"},{"location":"changelog/#v1100-2021-04-20","text":"Add filter mimetype Add action macos_tags Support simplematch syntax in lename -filter. Updated dependencies Because installing textract is quite hard on some platforms it is now an optional dendency. Install it with pip install organize-tool[textract] This version needs python 3.6 minimum. Some dependencies that were simply backports (thlib2, typing) are removed. Add timezones in created and last_modified filters (Thank you, @win0err!)","title":"v1.10.0 (2021-04-20)"},{"location":"changelog/#v191-2020-11-10","text":"Add {env} variable Add {now} variable","title":"v1.9.1 (2020-11-10)"},{"location":"changelog/#v19-2020-06-12","text":"Add filter Duplicate .","title":"v1.9 (2020-06-12)"},{"location":"changelog/#v182-2020-04-03","text":"Fix a bug in the filename filter config parsing algorithm with digits-only filenames.","title":"v1.8.2 (2020-04-03)"},{"location":"changelog/#v181-2020-03-28","text":"Flatten filter and action lists to allow enhanced config file configuration (Thanks to @rawdamedia!) Add support for multiline content filters (Thanks to @zor-el!)","title":"v1.8.1 (2020-03-28)"},{"location":"changelog/#v180-2020-03-04","text":"Added action Delete . Added filter FileContent . Python 3.4 is officially deprecated and no longer supported. --config-file command line option now supports ~ for user folder and expansion oenvironment variables Added years , months , weeks and seconds parameter to filter created and stmodified","title":"v1.8.0 (2020-03-04)"},{"location":"changelog/#v170-2019-11-26","text":"Added filter Exif to filter by image exif data. Placeholder variable properties are now case insensitve.","title":"v1.7.0 (2019-11-26)"},{"location":"changelog/#v162-2019-11-22","text":"Fix Rename action ( 'PosixPath' object has no attribute 'items' ). Use type hints everywhere.","title":"v1.6.2 (2019-11-22)"},{"location":"changelog/#v161-2019-10-25","text":"Shows a warning for missing folders instead of raising an exception.","title":"v1.6.1 (2019-10-25)"},{"location":"changelog/#v16-2019-08-19","text":"Added filter: Python Added filter: FileSize The organize module can now be run directly: python3 -m organize Various code simplifications and speedups. Fixes an issue with globstring file exclusion. Remove clint dependency as it is no longer maintained. Added various integration tests The \"~~ SIMULATION ~~\"-banner now takes up the whole terminal width","title":"v1.6 (2019-08-19)"},{"location":"changelog/#v153-2019-08-01","text":"Filename filter now supports lists.","title":"v1.5.3 (2019-08-01)"},{"location":"changelog/#v152-2019-07-29","text":"Environment variables in folder pathes are now expanded (syntax $name or ${name} a additionally %name% on windows). F example this allows the usage of e.g. %public/Desktop% in windows.","title":"v1.5.2 (2019-07-29)"},{"location":"changelog/#v151-2019-07-23","text":"New filter \"Created\" to filter by creation date. Fixes issue #39 where globstrings don't work most of the time. Integration test for issue #39 Support indented config files","title":"v1.5.1 (2019-07-23)"},{"location":"changelog/#v15-2019-07-17","text":"Fixes issue #31 where the {path} variable always resolves to the source path Updated dependencies Exclude changelog and readme from published wheel","title":"v1.5 (2019-07-17)"},{"location":"changelog/#v145-2019-07-03","text":"Filter and Actions names are now case-insensitive","title":"v1.4.5 (2019-07-03)"},{"location":"changelog/#v144-2019-07-02","text":"Fixes issues #36 with umlauts in config file on windows","title":"v1.4.4 (2019-07-02)"},{"location":"changelog/#v143-2019-06-05","text":"Use safe YAML loader to fix a deprecation warning. (Thanks mope1!) Better error message if a folder does not exist. (Again thanks mope1!) Fix example code in documentation for LastModified filter. Custom config file locations (given by cmd line argument or environment variable). config --debug now shows the full path to the config file.","title":"v1.4.3 (2019-06-05)"},{"location":"changelog/#v142-2018-11-14","text":"Fixes a bug with command line arguments in the $EDITOR environment viable. Fixes a bug where an empty config wouldn't show the correct error message. Fix binary wheel creation in setup.py by using environment markers","title":"v1.4.2 (2018-11-14)"},{"location":"changelog/#v141-2018-10-05","text":"A custom separator counter_separator can now be set in the actions Move, Cy and Rename.","title":"v1.4.1 (2018-10-05)"},{"location":"changelog/#v14-2018-09-21","text":"Fixes a bug where glob wildcards are not detected correctly Adds support for excluding folders and files via glob syntax. Makes sure that files are only handled once per rule.","title":"v1.4 (2018-09-21)"},{"location":"changelog/#v13-2018-07-06","text":"Glob support in folder configuration. New variable {relative_path} is now available in actions.","title":"v1.3 (2018-07-06)"},{"location":"changelog/#v12-2018-03-19","text":"Shows the relative path to files in subfolders.","title":"v1.2 (2018-03-19)"},{"location":"changelog/#v11-2018-03-13","text":"Removes the colon from extension filter output so {extension.lower} now rurns 'png' instead of '.png' .","title":"v1.1 (2018-03-13)"},{"location":"changelog/#v10-2018-03-13","text":"Initial release.","title":"v1.0 (2018-03-13)"},{"location":"configuration/","text":"Configuration # Editing the configuration # organize has a default config file if no other file is given. To edit the default configuration file: $ organize edit # opens in $EDITOR $ organize edit --editor=vim $ EDITOR=code organize edit To open the folder containing the configuration file: $ organize reveal $ organize reveal --path # show the full path to the default config To check your configuration run: $ organize check $ organize check --debug # check with debug output Running and simulating # To run / simulate the default config file: $ organize sim $ organize run To run / simulate a specific config file: $ organize sim [FILE] $ organize run [FILE] Optionally you can specify the working directory like this: $ organize sim [FILE] --working-dir=~/Documents Environment variables # ORGANIZE_CONFIG - The path to the default config file. NO_COLOR - if this is set, the output is not colored. EDITOR - The editor used to edit the config file. Parallelize jobs # To speed up organizing you can run multiple organize processes simultaniously like this (linux / macOS): organize run config_1.yaml & \\ organize run config_2.yaml & \\ organize run config_3.yaml & Make sure that the config files are independent from each other, meaning that no rule depends on another rule in another config file.","title":"Configuration"},{"location":"configuration/#configuration","text":"","title":"Configuration"},{"location":"configuration/#editing-the-configuration","text":"organize has a default config file if no other file is given. To edit the default configuration file: $ organize edit # opens in $EDITOR $ organize edit --editor=vim $ EDITOR=code organize edit To open the folder containing the configuration file: $ organize reveal $ organize reveal --path # show the full path to the default config To check your configuration run: $ organize check $ organize check --debug # check with debug output","title":"Editing the configuration"},{"location":"configuration/#running-and-simulating","text":"To run / simulate the default config file: $ organize sim $ organize run To run / simulate a specific config file: $ organize sim [FILE] $ organize run [FILE] Optionally you can specify the working directory like this: $ organize sim [FILE] --working-dir=~/Documents","title":"Running and simulating"},{"location":"configuration/#environment-variables","text":"ORGANIZE_CONFIG - The path to the default config file. NO_COLOR - if this is set, the output is not colored. EDITOR - The editor used to edit the config file.","title":"Environment variables"},{"location":"configuration/#parallelize-jobs","text":"To speed up organizing you can run multiple organize processes simultaniously like this (linux / macOS): organize run config_1.yaml & \\ organize run config_2.yaml & \\ organize run config_3.yaml & Make sure that the config files are independent from each other, meaning that no rule depends on another rule in another config file.","title":"Parallelize jobs"},{"location":"filters/","text":"Filters # This page shows the specifics of each filter. - How to exclude filters - # To exclude a filter, prefix the filter name with not (e.g. \"not empty\" , \"not extension\": jpg , etc). Note If you want to exclude all filters you can set the rule's filter_mode to none . Example: rules: # using filter_mode - locations: ~/Desktop filter_mode: \"none\" # <- excludes all filters: - empty - name: endswith: \"2022\" actions: - echo: \"{name}\" # Exclude a single filter - locations: ~/Desktop filters: - not extension: jpg # <- matches all non-jpgs - name: startswith: \"Invoice\" - not empty # <- matches files with content actions: - echo: \"{name}\" created # Matches files / folders by created date Parameters: years ( int ) \u2013 specify number of years months ( int ) \u2013 specify number of months weeks ( float ) \u2013 specify number of weeks days ( float ) \u2013 specify number of days hours ( float ) \u2013 specify number of hours minutes ( float ) \u2013 specify number of minutes seconds ( float ) \u2013 specify number of seconds mode ( str ) \u2013 either 'older' or 'newer'. 'older' matches files / folders created before the given time, 'newer' matches files / folders created within the given time. (default = 'older') Returns: {created} \u2013 The datetime the file / folder was created. Examples: Show all files on your desktop created at least 10 days ago rules: - name: Show all files on your desktop created at least 10 days ago locations: \"~/Desktop\" filters: - created: days: 10 actions: - echo: \"Was created at least 10 days ago\" Show all files on your desktop which were created within the last 5 hours rules: - name: Show all files on your desktop which were created within the last 5 hours locations: \"~/Desktop\" filters: - created: hours: 5 mode: newer actions: - echo: \"Was created within the last 5 hours\" Sort pdfs by year of creation rules: - name: Sort pdfs by year of creation locations: \"~/Documents\" filters: - extension: pdf - created actions: - move: \"~/Documents/PDF/{created.year}/\" Formatting the creation date rules: - name: Display the creation date locations: \"~/Documents\" filters: - extension: pdf - created actions: - echo: \"ISO Format: {created.strftime('%Y-%m-%d')}\" - echo: \"As timestamp: {created.timestamp() | int}\" duplicate # A fast duplicate file finder. This filter compares files byte by byte and finds identical files with potentially different filenames. Parameters: detect_original_by ( str ) \u2013 Detection method to distinguish between original and duplicate. Possible values are: \"first_seen\" : Whatever file is visited first is the original. This depends on the order of your location entries. \"name\" : The first entry sorted by name is the original. \"created\" : The first entry sorted by creation date is the original. \"lastmodified\" : The first file sorted by date of last modification is the original. You can reverse the sorting method by prefixing a - . So with detect_original_by: \"-created\" the file with the older creation date is the original and the younger file is the duplicate. This works on all methods, for example \"-first_seen\" , \"-name\" , \"-created\" , \"-lastmodified\" . Returns: {duplicate.original} - The path to the original Examples: Show all duplicate files in your desktop and download folder (and their subfolders) rules: - name: Show all duplicate files in your desktop and download folder (and their subfolders) locations: - ~/Desktop - ~/Downloads subfolders: true filters: - duplicate actions: - echo: \"{path} is a duplicate of {duplicate.original}\" Check for duplicated files between Desktop and a Zip file, select original by creation date rules: - name: \"Check for duplicated files between Desktop and a Zip file, select original by creation date\" locations: - ~/Desktop - zip://~/Desktop/backup.zip filters: - duplicate: detect_original_by: \"created\" actions: - echo: \"Duplicate found!\" empty # Finds empty dirs and files Examples: Recursively delete empty folders rules: - targets: dirs locations: - path: ~/Desktop max_depth: null filters: - empty actions: - delete exif # Filter by image EXIF data The exif filter can be used as a filter as well as a way to get exif information into your actions. :returns: {exif} -- a dict of all the collected exif inforamtion available in the file. Typically it consists of the following tags (if present in the file): - ``{exif.image}`` -- information related to the main image - ``{exif.exif}`` -- Exif information - ``{exif.gps}`` -- GPS information - ``{exif.interoperability}`` -- Interoperability information Show available EXIF data of your pictures rules: - name: \"Show available EXIF data of your pictures\" locations: - path: ~/Pictures max_depth: null filters: - exif actions: - echo: \"{exif}\" Copy all images which contain GPS information while keeping subfolder structure: rules: - name: \"GPS demo\" locations: - path: ~/Pictures max_depth: null filters: - exif: gps.gpsdate actions: - copy: ~/Pictures/with_gps/{relative_path}/ Filter by camera manufacturer rules: - name: \"Filter by camera manufacturer\" locations: - path: ~/Pictures max_depth: null filters: - exif: image.model: Nikon D3200 actions: - move: \"~/Pictures/My old Nikon/\" Sort images by camera manufacturer. This will create folders for each camera model (for example \"Nikon D3200\", \"iPhone 6s\", \"iPhone 5s\", \"DMC-GX80\") and move the pictures accordingly: rules: - name: \"camera sort\" locations: - path: ~/Pictures max_depth: null filters: - extension: jpg - exif: image.model actions: - move: \"~/Pictures/{exif.image.model}/\" extension # Filter by file extension Parameters: *extensions ( list(str) or str ) \u2013 The file extensions to match (does not need to start with a colon). Returns: {extension} : the original file extension (without colon) Examples: Match a single file extension rules: - name: \"Match a single file extension\" locations: \"~/Desktop\" filters: - extension: png actions: - echo: \"Found PNG file: {path}\" Match multiple file extensions rules: - name: \"Match multiple file extensions\" locations: \"~/Desktop\" filters: - extension: - .jpg - jpeg actions: - echo: \"Found JPG file: {path}\" Make all file extensions lowercase rules: - name: \"Make all file extensions lowercase\" locations: \"~/Desktop\" filters: - extension actions: - rename: \"{path.stem}.{extension.lower()}\" Using extension lists ( yaml aliases img_ext: &img - png - jpg - tiff audio_ext: &audio - mp3 - wav - ogg rules: - name: \"Using extension lists\" locations: \"~/Desktop\" filters: - extension: - *img - *audio actions: - echo: \"Found media file: {path}\" filecontent # Matches file content with the given regular expression Parameters: expr ( str ) \u2013 The regular expression to be matched. Any named groups ( (?P<groupname>.*) ) in your regular expression will be returned like this: Returns: {filecontent.groupname} : The text matched with the named group (?P<groupname>) Examples: Show the content of all your PDF files rules: - name: \"Show the content of all your PDF files\" locations: ~/Documents filters: - extension: pdf - filecontent actions: - echo: \"{filecontent}\" Match an invoice with a regular expression and sort by customer rules: - name: \"Match an invoice with a regular expression and sort by customer\" locations: \"~/Desktop\" filters: - filecontent: 'Invoice.*Customer (?P<customer>\\w+)' actions: - move: \"~/Documents/Invoices/{filecontent.customer}/\" Exampe to filter the filename with respect to a valid date code. The filename should start with <year>-<month>-<day> . Regex: creates a placeholder variable containing the year allows only years which start with 20 and are followed by 2 numbers months can only have as first digit 0 or 1 and must be followed by a number days can only have 0, 1,2 or 3 and must followed by number Note: Filter is not perfect but still. rules: - locations: ~/Desktop filters: - regex: '(?P<year>20\\d{2})-[01]\\d-[0123]\\d.*' actions: - echo: \"Year: {regex.year}\" hash # Calculates the hash of a file. Parameters: algorithm ( str ) \u2013 Any hashing algorithm available to python's hashlib . md5 by default. Algorithms guaranteed to be available are shake_256 , sha3_256 , sha1 , sha3_224 , sha384 , sha512 , blake2b , blake2s , sha256 , sha224 , shake_128 , sha3_512 , sha3_384 and md5 . Depending on your python installation and installed libs there may be additional hash algorithms to chose from. To list the available algorithms on your installation run this in a python interpreter: >>> import hashlib >>> hashlib.algorithms_available {'shake_256', 'whirlpool', 'mdc2', 'blake2s', 'sha224', 'shake_128', 'sha3_512', 'sha3_224', 'sha384', 'md5', 'sha1', 'sha512_256', 'blake2b', 'sha256', 'sha512_224', 'ripemd160', 'sha3_384', 'md4', 'sm3', 'sha3_256', 'md5-sha1', 'sha512'} Returns: {hash} : The hash of the file. Examples: Show the hashes of your files: rules: - name: \"Show the hashes and size of your files\" locations: \"~/Desktop\" filters: - hash - size actions: - echo: \"{hash} {size.decimal}\" lastmodified # Matches files by last modified date Parameters: years ( int ) \u2013 specify number of years months ( int ) \u2013 specify number of months weeks ( float ) \u2013 specify number of weeks days ( float ) \u2013 specify number of days hours ( float ) \u2013 specify number of hours minutes ( float ) \u2013 specify number of minutes seconds ( float ) \u2013 specify number of seconds mode ( str ) \u2013 either 'older' or 'newer'. 'older' matches files / folders last modified before the given time, 'newer' matches files / folders last modified within the given time. (default = 'older') Returns: {lastmodified} \u2013 The datetime the files / folders was lastmodified. Examples: rules: - name: \"Show all files on your desktop last modified at least 10 days ago\" locations: \"~/Desktop\" filters: - lastmodified: days: 10 actions: - echo: \"Was modified at least 10 days ago\" Show all files on your desktop which were modified within the last 5 hours: rules: - locations: \"~/Desktop\" filters: - lastmodified: hours: 5 mode: newer actions: - echo: \"Was modified within the last 5 hours\" Sort pdfs by year of last modification rules: - name: \"Sort pdfs by year of last modification\" locations: \"~/Documents\" filters: - extension: pdf - lastmodified actions: - move: \"~/Documents/PDF/{lastmodified.year}/\" Formatting the last modified date rules: - name: Formatting the lastmodified date locations: \"~/Documents\" filters: - extension: pdf - lastmodified actions: - echo: \"ISO Format: {lastmodified.strftime('%Y-%m-%d')}\" - echo: \"As timestamp: {lastmodified.timestamp() | int}\" mimetype # Filter by MIME type associated with the file extension. Supports a single string or list of MIME type strings as argument. The types don't need to be fully specified, for example \"audio\" matches everything from \"audio/midi\" to \"audio/quicktime\". You can see a list of known MIME types on your system by running this oneliner: python3 -c \"import mimetypes as m; print('\\n'.join(sorted(set(m.common_types.values()) | set(m.types_map.values()))))\" Parameters: *mimetypes ( list(str) or str ) \u2013 The MIME types to filter for. Returns: {mimetype} : The MIME type of the file. Examples: Show MIME types rules: - name: \"Show MIME types\" locations: \"~/Downloads\" filters: - mimetype actions: - echo: \"{mimetype}\" Filter by 'image' mimetype rules: - name: \"Filter by 'image' mimetype\" locations: \"~/Downloads\" filters: - mimetype: image actions: - echo: \"This file is an image: {mimetype}\" Filter by specific MIME type rules: - name: Filter by specific MIME type locations: \"~/Desktop\" filters: - mimetype: application/pdf actions: - echo: \"Found a PDF file\" Filter by multiple specific MIME types rules: - name: Filter by multiple specific MIME types locations: \"~/Music\" filters: - mimetype: - application/pdf - audio/midi actions: - echo: \"Found Midi or PDF.\" name # Match files and folders by name Parameters: match ( str ) \u2013 A matching string in simplematch-syntax startswith ( str ) \u2013 The filename must begin with the given string contains ( str ) \u2013 The filename must contain the given string endswith ( str ) \u2013 The filename (without extension) must end with the given string case_sensitive ( bool ) \u2013 By default, the matching is case sensitive. Change this to False to use case insensitive matching. Examples: Match all files starting with 'Invoice': rules: - locations: \"~/Desktop\" filters: - name: startswith: Invoice actions: - echo: \"This is an invoice\" Match all files starting with 'A' end containing the string 'hole' (case insensitive): rules: - locations: \"~/Desktop\" filters: - name: startswith: A contains: hole case_sensitive: false actions: - echo: \"Found a match.\" Match all files starting with 'A' or 'B' containing '5' or '6' and ending with '_end': rules: - locations: \"~/Desktop\" filters: - name: startswith: - \"A\" - \"B\" contains: - \"5\" - \"6\" endswith: _end case_sensitive: false actions: - echo: \"Found a match.\" python # Use python code to filter files. Parameters: code ( str ) \u2013 The python code to execute. The code must contain a return statement. Returns: If your code returns False or None the file is filtered out, otherwise the file is passed on to the next filters. {python} contains the returned value. If you return a dictionary (for example return {\"some_key\": some_value, \"nested\": {\"k\": 2}} ) it will be accessible via dot syntax in your actions: {python.some_key} , {python.nested.k} . Examples: rules: - name: A file name reverser. locations: ~/Documents filters: - extension - python: | return {\"reversed_name\": path.stem[::-1]} actions: - rename: \"{python.reversed_name}.{extension}\" A filter for odd student numbers. Assuming the folder ~/Students contains the files student-01.jpg , student-01.txt , student-02.txt and student-03.txt this rule will print \"Odd student numbers: student-01.txt\" and \"Odd student numbers: student-03.txt\" rules: - name: \"Filter odd student numbers\" locations: ~/Students/ filters: - python: | return int(path.stem.split('-')[1]) % 2 == 1 actions: - echo: \"Odd student numbers: {path.name}\" Advanced usecase. You can access data from previous filters in your python code. This can be used to match files and capturing names with a regular expression and then renaming the files with the output of your python script. rules: - name: \"Access placeholders in python filter\" locations: files filters: - extension: txt - regex: (?P<firstname>\\w+)-(?P<lastname>\\w+)\\..* - python: | emails = { \"Betts\": \"dbetts@mail.de\", \"Cornish\": \"acornish@google.com\", \"Bean\": \"dbean@aol.com\", \"Frey\": \"l-frey@frey.org\", } if regex.lastname in emails: # get emails from wherever return {\"mail\": emails[regex.lastname]} actions: - rename: \"{python.mail}.txt\" Result: Devonte-Betts.txt becomes dbetts@mail.de.txt Alaina-Cornish.txt becomes acornish@google.com.txt Dimitri-Bean.txt becomes dbean@aol.com.txt Lowri-Frey.txt becomes l-frey@frey.org.txt Someunknown-User.txt remains unchanged because the email is not found regex # Matches filenames with the given regular expression Parameters: expr ( str ) \u2013 The regular expression to be matched. Returns: Any named groups in your regular expression will be returned like this: {regex.groupname} : The text matched with the named group (?P<groupname>.*) Examples: Match an invoice with a regular expression: rules: - locations: \"~/Desktop\" filters: - regex: '^RG(\\d{12})-sig\\.pdf$' actions: - move: \"~/Documents/Invoices/1und1/\" Match and extract data from filenames with regex named groups: This is just like the previous example but we rename the invoice using the invoice number extracted via the regular expression and the named group the_number . rules: - locations: ~/Desktop filters: - regex: '^RG(?P<the_number>\\d{12})-sig\\.pdf$' actions: - move: ~/Documents/Invoices/1und1/{regex.the_number}.pdf size # Matches files and folders by size Parameters: *conditions ( list(str) or str ) \u2013 The size constraints. Accepts file size conditions, e.g: \">= 500 MB\" , \"< 20k\" , \">0\" , \"= 10 KiB\" . It is possible to define both lower and upper conditions like this: \">20k, < 1 TB\" , \">= 20 Mb, <25 Mb\" . The filter will match if all given conditions are satisfied. Accepts all units from KB to YB. If no unit is given, kilobytes are assumend. If binary prefix is given (KiB, GiB) the size is calculated using base 1024. Returns: {size.bytes} : (int) Size in bytes {size.traditional} : (str) Size with unit (powers of 1024, JDEC prefixes) {size.binary} : (str) Size with unit (powers of 1024, IEC prefixes) {size.decimal} : (str) Size with unit (powers of 1000, SI prefixes) Examples: Trash big downloads: rules: - locations: \"~/Downloads\" targets: files filters: - size: \"> 0.5 GB\" actions: - trash Move all JPEGS bigger > 1MB and <10 MB. Search all subfolders and keep the original relative path. rules: - locations: - path: \"~/Pictures\" max_depth: null filters: - extension: - jpg - jpeg - size: \">1mb, <10mb\" actions: - move: \"~/Pictures/sorted/{relative_path}/\"","title":"Filters"},{"location":"filters/#filters","text":"This page shows the specifics of each filter.","title":"Filters"},{"location":"filters/#-how-to-exclude-filters-","text":"To exclude a filter, prefix the filter name with not (e.g. \"not empty\" , \"not extension\": jpg , etc). Note If you want to exclude all filters you can set the rule's filter_mode to none . Example: rules: # using filter_mode - locations: ~/Desktop filter_mode: \"none\" # <- excludes all filters: - empty - name: endswith: \"2022\" actions: - echo: \"{name}\" # Exclude a single filter - locations: ~/Desktop filters: - not extension: jpg # <- matches all non-jpgs - name: startswith: \"Invoice\" - not empty # <- matches files with content actions: - echo: \"{name}\"","title":"- How to exclude filters -"},{"location":"filters/#created","text":"Matches files / folders by created date Parameters: years ( int ) \u2013 specify number of years months ( int ) \u2013 specify number of months weeks ( float ) \u2013 specify number of weeks days ( float ) \u2013 specify number of days hours ( float ) \u2013 specify number of hours minutes ( float ) \u2013 specify number of minutes seconds ( float ) \u2013 specify number of seconds mode ( str ) \u2013 either 'older' or 'newer'. 'older' matches files / folders created before the given time, 'newer' matches files / folders created within the given time. (default = 'older') Returns: {created} \u2013 The datetime the file / folder was created. Examples: Show all files on your desktop created at least 10 days ago rules: - name: Show all files on your desktop created at least 10 days ago locations: \"~/Desktop\" filters: - created: days: 10 actions: - echo: \"Was created at least 10 days ago\" Show all files on your desktop which were created within the last 5 hours rules: - name: Show all files on your desktop which were created within the last 5 hours locations: \"~/Desktop\" filters: - created: hours: 5 mode: newer actions: - echo: \"Was created within the last 5 hours\" Sort pdfs by year of creation rules: - name: Sort pdfs by year of creation locations: \"~/Documents\" filters: - extension: pdf - created actions: - move: \"~/Documents/PDF/{created.year}/\" Formatting the creation date rules: - name: Display the creation date locations: \"~/Documents\" filters: - extension: pdf - created actions: - echo: \"ISO Format: {created.strftime('%Y-%m-%d')}\" - echo: \"As timestamp: {created.timestamp() | int}\"","title":"created"},{"location":"filters/#duplicate","text":"A fast duplicate file finder. This filter compares files byte by byte and finds identical files with potentially different filenames. Parameters: detect_original_by ( str ) \u2013 Detection method to distinguish between original and duplicate. Possible values are: \"first_seen\" : Whatever file is visited first is the original. This depends on the order of your location entries. \"name\" : The first entry sorted by name is the original. \"created\" : The first entry sorted by creation date is the original. \"lastmodified\" : The first file sorted by date of last modification is the original. You can reverse the sorting method by prefixing a - . So with detect_original_by: \"-created\" the file with the older creation date is the original and the younger file is the duplicate. This works on all methods, for example \"-first_seen\" , \"-name\" , \"-created\" , \"-lastmodified\" . Returns: {duplicate.original} - The path to the original Examples: Show all duplicate files in your desktop and download folder (and their subfolders) rules: - name: Show all duplicate files in your desktop and download folder (and their subfolders) locations: - ~/Desktop - ~/Downloads subfolders: true filters: - duplicate actions: - echo: \"{path} is a duplicate of {duplicate.original}\" Check for duplicated files between Desktop and a Zip file, select original by creation date rules: - name: \"Check for duplicated files between Desktop and a Zip file, select original by creation date\" locations: - ~/Desktop - zip://~/Desktop/backup.zip filters: - duplicate: detect_original_by: \"created\" actions: - echo: \"Duplicate found!\"","title":"duplicate"},{"location":"filters/#empty","text":"Finds empty dirs and files Examples: Recursively delete empty folders rules: - targets: dirs locations: - path: ~/Desktop max_depth: null filters: - empty actions: - delete","title":"empty"},{"location":"filters/#exif","text":"Filter by image EXIF data The exif filter can be used as a filter as well as a way to get exif information into your actions. :returns: {exif} -- a dict of all the collected exif inforamtion available in the file. Typically it consists of the following tags (if present in the file): - ``{exif.image}`` -- information related to the main image - ``{exif.exif}`` -- Exif information - ``{exif.gps}`` -- GPS information - ``{exif.interoperability}`` -- Interoperability information Show available EXIF data of your pictures rules: - name: \"Show available EXIF data of your pictures\" locations: - path: ~/Pictures max_depth: null filters: - exif actions: - echo: \"{exif}\" Copy all images which contain GPS information while keeping subfolder structure: rules: - name: \"GPS demo\" locations: - path: ~/Pictures max_depth: null filters: - exif: gps.gpsdate actions: - copy: ~/Pictures/with_gps/{relative_path}/ Filter by camera manufacturer rules: - name: \"Filter by camera manufacturer\" locations: - path: ~/Pictures max_depth: null filters: - exif: image.model: Nikon D3200 actions: - move: \"~/Pictures/My old Nikon/\" Sort images by camera manufacturer. This will create folders for each camera model (for example \"Nikon D3200\", \"iPhone 6s\", \"iPhone 5s\", \"DMC-GX80\") and move the pictures accordingly: rules: - name: \"camera sort\" locations: - path: ~/Pictures max_depth: null filters: - extension: jpg - exif: image.model actions: - move: \"~/Pictures/{exif.image.model}/\"","title":"exif"},{"location":"filters/#extension","text":"Filter by file extension Parameters: *extensions ( list(str) or str ) \u2013 The file extensions to match (does not need to start with a colon). Returns: {extension} : the original file extension (without colon) Examples: Match a single file extension rules: - name: \"Match a single file extension\" locations: \"~/Desktop\" filters: - extension: png actions: - echo: \"Found PNG file: {path}\" Match multiple file extensions rules: - name: \"Match multiple file extensions\" locations: \"~/Desktop\" filters: - extension: - .jpg - jpeg actions: - echo: \"Found JPG file: {path}\" Make all file extensions lowercase rules: - name: \"Make all file extensions lowercase\" locations: \"~/Desktop\" filters: - extension actions: - rename: \"{path.stem}.{extension.lower()}\" Using extension lists ( yaml aliases img_ext: &img - png - jpg - tiff audio_ext: &audio - mp3 - wav - ogg rules: - name: \"Using extension lists\" locations: \"~/Desktop\" filters: - extension: - *img - *audio actions: - echo: \"Found media file: {path}\"","title":"extension"},{"location":"filters/#filecontent","text":"Matches file content with the given regular expression Parameters: expr ( str ) \u2013 The regular expression to be matched. Any named groups ( (?P<groupname>.*) ) in your regular expression will be returned like this: Returns: {filecontent.groupname} : The text matched with the named group (?P<groupname>) Examples: Show the content of all your PDF files rules: - name: \"Show the content of all your PDF files\" locations: ~/Documents filters: - extension: pdf - filecontent actions: - echo: \"{filecontent}\" Match an invoice with a regular expression and sort by customer rules: - name: \"Match an invoice with a regular expression and sort by customer\" locations: \"~/Desktop\" filters: - filecontent: 'Invoice.*Customer (?P<customer>\\w+)' actions: - move: \"~/Documents/Invoices/{filecontent.customer}/\" Exampe to filter the filename with respect to a valid date code. The filename should start with <year>-<month>-<day> . Regex: creates a placeholder variable containing the year allows only years which start with 20 and are followed by 2 numbers months can only have as first digit 0 or 1 and must be followed by a number days can only have 0, 1,2 or 3 and must followed by number Note: Filter is not perfect but still. rules: - locations: ~/Desktop filters: - regex: '(?P<year>20\\d{2})-[01]\\d-[0123]\\d.*' actions: - echo: \"Year: {regex.year}\"","title":"filecontent"},{"location":"filters/#hash","text":"Calculates the hash of a file. Parameters: algorithm ( str ) \u2013 Any hashing algorithm available to python's hashlib . md5 by default. Algorithms guaranteed to be available are shake_256 , sha3_256 , sha1 , sha3_224 , sha384 , sha512 , blake2b , blake2s , sha256 , sha224 , shake_128 , sha3_512 , sha3_384 and md5 . Depending on your python installation and installed libs there may be additional hash algorithms to chose from. To list the available algorithms on your installation run this in a python interpreter: >>> import hashlib >>> hashlib.algorithms_available {'shake_256', 'whirlpool', 'mdc2', 'blake2s', 'sha224', 'shake_128', 'sha3_512', 'sha3_224', 'sha384', 'md5', 'sha1', 'sha512_256', 'blake2b', 'sha256', 'sha512_224', 'ripemd160', 'sha3_384', 'md4', 'sm3', 'sha3_256', 'md5-sha1', 'sha512'} Returns: {hash} : The hash of the file. Examples: Show the hashes of your files: rules: - name: \"Show the hashes and size of your files\" locations: \"~/Desktop\" filters: - hash - size actions: - echo: \"{hash} {size.decimal}\"","title":"hash"},{"location":"filters/#lastmodified","text":"Matches files by last modified date Parameters: years ( int ) \u2013 specify number of years months ( int ) \u2013 specify number of months weeks ( float ) \u2013 specify number of weeks days ( float ) \u2013 specify number of days hours ( float ) \u2013 specify number of hours minutes ( float ) \u2013 specify number of minutes seconds ( float ) \u2013 specify number of seconds mode ( str ) \u2013 either 'older' or 'newer'. 'older' matches files / folders last modified before the given time, 'newer' matches files / folders last modified within the given time. (default = 'older') Returns: {lastmodified} \u2013 The datetime the files / folders was lastmodified. Examples: rules: - name: \"Show all files on your desktop last modified at least 10 days ago\" locations: \"~/Desktop\" filters: - lastmodified: days: 10 actions: - echo: \"Was modified at least 10 days ago\" Show all files on your desktop which were modified within the last 5 hours: rules: - locations: \"~/Desktop\" filters: - lastmodified: hours: 5 mode: newer actions: - echo: \"Was modified within the last 5 hours\" Sort pdfs by year of last modification rules: - name: \"Sort pdfs by year of last modification\" locations: \"~/Documents\" filters: - extension: pdf - lastmodified actions: - move: \"~/Documents/PDF/{lastmodified.year}/\" Formatting the last modified date rules: - name: Formatting the lastmodified date locations: \"~/Documents\" filters: - extension: pdf - lastmodified actions: - echo: \"ISO Format: {lastmodified.strftime('%Y-%m-%d')}\" - echo: \"As timestamp: {lastmodified.timestamp() | int}\"","title":"lastmodified"},{"location":"filters/#mimetype","text":"Filter by MIME type associated with the file extension. Supports a single string or list of MIME type strings as argument. The types don't need to be fully specified, for example \"audio\" matches everything from \"audio/midi\" to \"audio/quicktime\". You can see a list of known MIME types on your system by running this oneliner: python3 -c \"import mimetypes as m; print('\\n'.join(sorted(set(m.common_types.values()) | set(m.types_map.values()))))\" Parameters: *mimetypes ( list(str) or str ) \u2013 The MIME types to filter for. Returns: {mimetype} : The MIME type of the file. Examples: Show MIME types rules: - name: \"Show MIME types\" locations: \"~/Downloads\" filters: - mimetype actions: - echo: \"{mimetype}\" Filter by 'image' mimetype rules: - name: \"Filter by 'image' mimetype\" locations: \"~/Downloads\" filters: - mimetype: image actions: - echo: \"This file is an image: {mimetype}\" Filter by specific MIME type rules: - name: Filter by specific MIME type locations: \"~/Desktop\" filters: - mimetype: application/pdf actions: - echo: \"Found a PDF file\" Filter by multiple specific MIME types rules: - name: Filter by multiple specific MIME types locations: \"~/Music\" filters: - mimetype: - application/pdf - audio/midi actions: - echo: \"Found Midi or PDF.\"","title":"mimetype"},{"location":"filters/#name","text":"Match files and folders by name Parameters: match ( str ) \u2013 A matching string in simplematch-syntax startswith ( str ) \u2013 The filename must begin with the given string contains ( str ) \u2013 The filename must contain the given string endswith ( str ) \u2013 The filename (without extension) must end with the given string case_sensitive ( bool ) \u2013 By default, the matching is case sensitive. Change this to False to use case insensitive matching. Examples: Match all files starting with 'Invoice': rules: - locations: \"~/Desktop\" filters: - name: startswith: Invoice actions: - echo: \"This is an invoice\" Match all files starting with 'A' end containing the string 'hole' (case insensitive): rules: - locations: \"~/Desktop\" filters: - name: startswith: A contains: hole case_sensitive: false actions: - echo: \"Found a match.\" Match all files starting with 'A' or 'B' containing '5' or '6' and ending with '_end': rules: - locations: \"~/Desktop\" filters: - name: startswith: - \"A\" - \"B\" contains: - \"5\" - \"6\" endswith: _end case_sensitive: false actions: - echo: \"Found a match.\"","title":"name"},{"location":"filters/#python","text":"Use python code to filter files. Parameters: code ( str ) \u2013 The python code to execute. The code must contain a return statement. Returns: If your code returns False or None the file is filtered out, otherwise the file is passed on to the next filters. {python} contains the returned value. If you return a dictionary (for example return {\"some_key\": some_value, \"nested\": {\"k\": 2}} ) it will be accessible via dot syntax in your actions: {python.some_key} , {python.nested.k} . Examples: rules: - name: A file name reverser. locations: ~/Documents filters: - extension - python: | return {\"reversed_name\": path.stem[::-1]} actions: - rename: \"{python.reversed_name}.{extension}\" A filter for odd student numbers. Assuming the folder ~/Students contains the files student-01.jpg , student-01.txt , student-02.txt and student-03.txt this rule will print \"Odd student numbers: student-01.txt\" and \"Odd student numbers: student-03.txt\" rules: - name: \"Filter odd student numbers\" locations: ~/Students/ filters: - python: | return int(path.stem.split('-')[1]) % 2 == 1 actions: - echo: \"Odd student numbers: {path.name}\" Advanced usecase. You can access data from previous filters in your python code. This can be used to match files and capturing names with a regular expression and then renaming the files with the output of your python script. rules: - name: \"Access placeholders in python filter\" locations: files filters: - extension: txt - regex: (?P<firstname>\\w+)-(?P<lastname>\\w+)\\..* - python: | emails = { \"Betts\": \"dbetts@mail.de\", \"Cornish\": \"acornish@google.com\", \"Bean\": \"dbean@aol.com\", \"Frey\": \"l-frey@frey.org\", } if regex.lastname in emails: # get emails from wherever return {\"mail\": emails[regex.lastname]} actions: - rename: \"{python.mail}.txt\" Result: Devonte-Betts.txt becomes dbetts@mail.de.txt Alaina-Cornish.txt becomes acornish@google.com.txt Dimitri-Bean.txt becomes dbean@aol.com.txt Lowri-Frey.txt becomes l-frey@frey.org.txt Someunknown-User.txt remains unchanged because the email is not found","title":"python"},{"location":"filters/#regex","text":"Matches filenames with the given regular expression Parameters: expr ( str ) \u2013 The regular expression to be matched. Returns: Any named groups in your regular expression will be returned like this: {regex.groupname} : The text matched with the named group (?P<groupname>.*) Examples: Match an invoice with a regular expression: rules: - locations: \"~/Desktop\" filters: - regex: '^RG(\\d{12})-sig\\.pdf$' actions: - move: \"~/Documents/Invoices/1und1/\" Match and extract data from filenames with regex named groups: This is just like the previous example but we rename the invoice using the invoice number extracted via the regular expression and the named group the_number . rules: - locations: ~/Desktop filters: - regex: '^RG(?P<the_number>\\d{12})-sig\\.pdf$' actions: - move: ~/Documents/Invoices/1und1/{regex.the_number}.pdf","title":"regex"},{"location":"filters/#size","text":"Matches files and folders by size Parameters: *conditions ( list(str) or str ) \u2013 The size constraints. Accepts file size conditions, e.g: \">= 500 MB\" , \"< 20k\" , \">0\" , \"= 10 KiB\" . It is possible to define both lower and upper conditions like this: \">20k, < 1 TB\" , \">= 20 Mb, <25 Mb\" . The filter will match if all given conditions are satisfied. Accepts all units from KB to YB. If no unit is given, kilobytes are assumend. If binary prefix is given (KiB, GiB) the size is calculated using base 1024. Returns: {size.bytes} : (int) Size in bytes {size.traditional} : (str) Size with unit (powers of 1024, JDEC prefixes) {size.binary} : (str) Size with unit (powers of 1024, IEC prefixes) {size.decimal} : (str) Size with unit (powers of 1000, SI prefixes) Examples: Trash big downloads: rules: - locations: \"~/Downloads\" targets: files filters: - size: \"> 0.5 GB\" actions: - trash Move all JPEGS bigger > 1MB and <10 MB. Search all subfolders and keep the original relative path. rules: - locations: - path: \"~/Pictures\" max_depth: null filters: - extension: - jpg - jpeg - size: \">1mb, <10mb\" actions: - move: \"~/Pictures/sorted/{relative_path}/\"","title":"size"},{"location":"locations/","text":"Locations # Locations are the folders in which organize searches for resources. You can set multiple locations for each rule if you want. A minimum location definition is just a path where to look for files / folders: rules: - locations: ~/Desktop actions: ... If you want to handle multiple locations in a rule, create a list: rules: - locations: - ~/Desktop - /usr/bin/ - \"%PROGRAMDATA%/test\" actions: ... Using options: rules: - name: \"Location list\" locations: - path: \"~/Desktop\" max_depth: 3 actions: ... Location options # rules: - locations: - path: ... max_depth: ... search: ... exclude_files: ... exclude_dirs: ... system_exclude_files: ... system_exclude_dirs: ... ignore_errors: ... filter: ... filter_dirs: ... filesystem: ... path ( str ) Path to a local folder or a Filesystem URL . max_depth ( int or null ) Maximum directory depth to search. search ( \"breadth\" or \"depth\" ) Whether to use breadth or depth search to recurse into subfolders. Note that if you want to move or delete files from this location, this has to be set to \"depth\" . (Default: \"depth\" ) exclude_files ( List[str] ) A list of filename patterns that should be excluded in this location, e.g. [\"~*\"] . exclude_dirs ( List[str] ) A list of patterns that will filter be used to filter out directory names in this location. e.g. ['do-not-move', '*-Important'] system_exclude_files ( List[str] ) The list of filename patterns that are excluded by default. Defaults to: [\"thumbs.db\", \"desktop.ini\", \"~$*\", \".DS_Store\", \".localized\"] system_exclude_dirs ( List[str] ) The list of dir names that are excluded by default ( ['.git', '.svn'] ) ignore_errors ( bool ) If true , any errors reading the location will be ignored. filter ( List[str] ) A list of filename patterns that should be used in this location, e.g. [\"*.py\"] . All other files are skipped. filter_dirs ( List[str] ) A list of patterns to match directory names that are included in this location. All other directories are skipped. filesystem (str) A Filesystem URL . filesystem and path # If you want the location to be the root ( \"/\" ) of a filesystem, use path : rules: - locations: - path: zip:///Users/theuser/Downloads/Test.zip If you want the location to be a subfolder inside a filesystem, use path and filesystem : rules: - locations: - filesystem: zip:///Users/theuser/Downloads/Test.zip path: \"/folder/in/the/zipfile/\" max_depth and subfolders # If subfolders: true is specified on the rule, all locations are set to max_depth: null by default. A max_depth setting in a location is given precedence over the rule's subfolders setting. Environment variables in locations # You can use environment variables in your locations. You can access them via the {env} placeholder or prefix them with a dollar sign. Examples: rules: - locations: # via {env} - the \"\" are important here! - \"{env.MY_FOLDER}\" # via $ - equal to the one above. - \"$MY_FOLDER\" # with location options - path: \"{env.OTHER_FOLDER}/Inbox/Invoices\" max_depth: null actions: - echo: \"{path}\" Remote filesystems and archives # Locations in organize can include: Folders on the harddrive ZIP archives TAR archives FTP servers S3 Buckets SSH and SMB connections IMAP servers WebDAV storages Dropbox / OneDrive / Google Drive storage (no need to install the client) Azure Datalake / Google Cloud Storage and many more! You can uses these just like the local harddrive, move/copy files or folders between them or organize them however you want. Filesystem URLs are formatted like this: <protocol>://<username>:<password>@<resource> # Examples: ftp://ftp.example.org/pub ftps://will:daffodil@ftp.example.org/private zip://projects.zip s3://mybucket dropbox://dropbox.com?access_token=<dropbox access token> ssh://[user[:password]@]host[:port] Note The ZIP, TAR, FTP and AppFS filesystems are builtin. For all other filesystems you need to install the appropriate library . FTP Example Show the size of all JPGs on a remote FTP server and put them into a local ZIP file. rules: - locations: \"ftps://demo:{env.FTP_PASSWORD}@demo.wftpserver.com\" subfolders: true filters: - size - extension: jpg actions: - echo: \"Found file! Size: {size.decimal}\" - copy: dest: \"{relative_path}\" filesystem: zip:///Users/thomas/Desktop/ftpfiles.zip Note You should never include a password in a config file. Better pass them in via an environment variable ( {env.FTP_PASSWORD} ) as you can see above. Relative locations # Locations can be relative. This allows you to create simple one-off rules that can be copied between projects. There is a command line option to change the working directory should you need it. huge-pic-warner.yaml: rules: - locations: \"docs\" # here \"docs\" is relative to the current working dir filters: - extension: jpg - size: \">3 MB\" actions: - echo: \"Warning - huge pic found!\" Then run it with: organize sim huge-pic-warner.yaml --working-dir=some/other/dir/","title":"Locations"},{"location":"locations/#locations","text":"Locations are the folders in which organize searches for resources. You can set multiple locations for each rule if you want. A minimum location definition is just a path where to look for files / folders: rules: - locations: ~/Desktop actions: ... If you want to handle multiple locations in a rule, create a list: rules: - locations: - ~/Desktop - /usr/bin/ - \"%PROGRAMDATA%/test\" actions: ... Using options: rules: - name: \"Location list\" locations: - path: \"~/Desktop\" max_depth: 3 actions: ...","title":"Locations"},{"location":"locations/#location-options","text":"rules: - locations: - path: ... max_depth: ... search: ... exclude_files: ... exclude_dirs: ... system_exclude_files: ... system_exclude_dirs: ... ignore_errors: ... filter: ... filter_dirs: ... filesystem: ... path ( str ) Path to a local folder or a Filesystem URL . max_depth ( int or null ) Maximum directory depth to search. search ( \"breadth\" or \"depth\" ) Whether to use breadth or depth search to recurse into subfolders. Note that if you want to move or delete files from this location, this has to be set to \"depth\" . (Default: \"depth\" ) exclude_files ( List[str] ) A list of filename patterns that should be excluded in this location, e.g. [\"~*\"] . exclude_dirs ( List[str] ) A list of patterns that will filter be used to filter out directory names in this location. e.g. ['do-not-move', '*-Important'] system_exclude_files ( List[str] ) The list of filename patterns that are excluded by default. Defaults to: [\"thumbs.db\", \"desktop.ini\", \"~$*\", \".DS_Store\", \".localized\"] system_exclude_dirs ( List[str] ) The list of dir names that are excluded by default ( ['.git', '.svn'] ) ignore_errors ( bool ) If true , any errors reading the location will be ignored. filter ( List[str] ) A list of filename patterns that should be used in this location, e.g. [\"*.py\"] . All other files are skipped. filter_dirs ( List[str] ) A list of patterns to match directory names that are included in this location. All other directories are skipped. filesystem (str) A Filesystem URL .","title":"Location options"},{"location":"locations/#filesystem-and-path","text":"If you want the location to be the root ( \"/\" ) of a filesystem, use path : rules: - locations: - path: zip:///Users/theuser/Downloads/Test.zip If you want the location to be a subfolder inside a filesystem, use path and filesystem : rules: - locations: - filesystem: zip:///Users/theuser/Downloads/Test.zip path: \"/folder/in/the/zipfile/\"","title":"filesystem and path"},{"location":"locations/#max_depth-and-subfolders","text":"If subfolders: true is specified on the rule, all locations are set to max_depth: null by default. A max_depth setting in a location is given precedence over the rule's subfolders setting.","title":"max_depth and subfolders"},{"location":"locations/#environment-variables-in-locations","text":"You can use environment variables in your locations. You can access them via the {env} placeholder or prefix them with a dollar sign. Examples: rules: - locations: # via {env} - the \"\" are important here! - \"{env.MY_FOLDER}\" # via $ - equal to the one above. - \"$MY_FOLDER\" # with location options - path: \"{env.OTHER_FOLDER}/Inbox/Invoices\" max_depth: null actions: - echo: \"{path}\"","title":"Environment variables in locations"},{"location":"locations/#remote-filesystems-and-archives","text":"Locations in organize can include: Folders on the harddrive ZIP archives TAR archives FTP servers S3 Buckets SSH and SMB connections IMAP servers WebDAV storages Dropbox / OneDrive / Google Drive storage (no need to install the client) Azure Datalake / Google Cloud Storage and many more! You can uses these just like the local harddrive, move/copy files or folders between them or organize them however you want. Filesystem URLs are formatted like this: <protocol>://<username>:<password>@<resource> # Examples: ftp://ftp.example.org/pub ftps://will:daffodil@ftp.example.org/private zip://projects.zip s3://mybucket dropbox://dropbox.com?access_token=<dropbox access token> ssh://[user[:password]@]host[:port] Note The ZIP, TAR, FTP and AppFS filesystems are builtin. For all other filesystems you need to install the appropriate library . FTP Example Show the size of all JPGs on a remote FTP server and put them into a local ZIP file. rules: - locations: \"ftps://demo:{env.FTP_PASSWORD}@demo.wftpserver.com\" subfolders: true filters: - size - extension: jpg actions: - echo: \"Found file! Size: {size.decimal}\" - copy: dest: \"{relative_path}\" filesystem: zip:///Users/thomas/Desktop/ftpfiles.zip Note You should never include a password in a config file. Better pass them in via an environment variable ( {env.FTP_PASSWORD} ) as you can see above.","title":"Remote filesystems and archives"},{"location":"locations/#relative-locations","text":"Locations can be relative. This allows you to create simple one-off rules that can be copied between projects. There is a command line option to change the working directory should you need it. huge-pic-warner.yaml: rules: - locations: \"docs\" # here \"docs\" is relative to the current working dir filters: - extension: jpg - size: \">3 MB\" actions: - echo: \"Warning - huge pic found!\" Then run it with: organize sim huge-pic-warner.yaml --working-dir=some/other/dir/","title":"Relative locations"},{"location":"rules/","text":"Rules # A organize config file can be written in YAML or JSON . See configuration on how to locate your config file. The top level element must be a dict with a key \"rules\". \"rules\" contains a list of objects with the required keys \"locations\" and \"actions\". A minimum config: rules: - locations: \"~/Desktop\" actions: - echo: \"Hello World!\" Organize checks your rules from top to bottom. For every resource in each location (top to bottom) it will check whether the filters apply (top to bottom) and then execute the given actions (top to bottom). So with this minimal configuration it will print \"Hello World!\" for each file it finds in your Desktop. Rule options # rules: # First rule - name: ... enabled: ... targets: ... locations: ... subfolders: ... filter_mode: ... filters: ... actions: ... # Another rule - name: ... enabled: ... # ... and so on The rule options in detail: name ( str ): The rule name enabled ( bool ): Whether the rule is enabled / disabled (Default: true ) targets ( str ): \"dirs\" or \"files\" (Default: \"files\" ) locations ( str | list ) - A single location string or list of locations subfolders ( bool ): Whether to recurse into subfolders of all locations (Default: false ) filter_mode ( str ): \"all\" , \"any\" or \"none\" of the filters must apply (Default: \"all\" ) filters ( list ): A list of filters (Default: [] ) actions ( list ): A list of actions Targeting directories # When targets is set to dirs , organize will work on the folders, not on files. The filters adjust their meaning automatically. For example the size filter sums up the size of all files contained in the given folder instead of returning the size of a single file. Of course other filters like exif or filecontent do not work on folders and will return an error. Templates and placeholders # Placeholder variables are used with curly braces {var} . These variables are always available : {env} ( dict ) All your environment variables. You can access individual env vars like this: {env.MY_VARIABLE} . {path} ( pathlib.Path ) The full path to the current file / folder on the local harddrive. This is not available for remote locations - in this case use fs and fs_path . {relative_path} ( str ) the relative path of the current file in {fs} . {now} ( datetime ) The current datetime in the local timezone. {utcnow} ( datetime ) The current UTC datetime. {fs} ( FS ) The filesystem of the current location. Normally you should not need this. {fs_path} ( str ) The path of the current file / folder in related to fs . Normally you should not need this. In addition to that nearly all filters add new placeholders with information about the currently handled file / folder. Example on how to access the size and hash of a file: rules: - locations: ~/Desktop filters: - size - hash actions: - echo: \"{size} {hash}\" Note In order to use a value returned by a filter it must be listed in the filters! Advanced: Aliases # Instead of repeating the same locations / actions / filters in each and every rule you can use an alias for multiple locations which you can then reference in each rule. Aliases are a standard feature of the YAML syntax. all_my_messy_folders: &all - ~/Desktop - ~/Downloads - ~/Documents - ~/Dropbox rules: - locations: *all filters: ... actions: ... - locations: *all filters: ... actions: ... You can even use multiple folder lists: private_folders: &private - \"/path/private\" - \"~/path/private\" work_folders: &work - \"/path/work\" - \"~/My work folder\" all_folders: &all - *private - *work rules: - locations: *private filters: ... actions: ... - locations: *work filters: ... actions: ... - locations: *all filters: ... actions: ... # same as *all - locations: - *work - *private filters: ... actions: ...","title":"Rules"},{"location":"rules/#rules","text":"A organize config file can be written in YAML or JSON . See configuration on how to locate your config file. The top level element must be a dict with a key \"rules\". \"rules\" contains a list of objects with the required keys \"locations\" and \"actions\". A minimum config: rules: - locations: \"~/Desktop\" actions: - echo: \"Hello World!\" Organize checks your rules from top to bottom. For every resource in each location (top to bottom) it will check whether the filters apply (top to bottom) and then execute the given actions (top to bottom). So with this minimal configuration it will print \"Hello World!\" for each file it finds in your Desktop.","title":"Rules"},{"location":"rules/#rule-options","text":"rules: # First rule - name: ... enabled: ... targets: ... locations: ... subfolders: ... filter_mode: ... filters: ... actions: ... # Another rule - name: ... enabled: ... # ... and so on The rule options in detail: name ( str ): The rule name enabled ( bool ): Whether the rule is enabled / disabled (Default: true ) targets ( str ): \"dirs\" or \"files\" (Default: \"files\" ) locations ( str | list ) - A single location string or list of locations subfolders ( bool ): Whether to recurse into subfolders of all locations (Default: false ) filter_mode ( str ): \"all\" , \"any\" or \"none\" of the filters must apply (Default: \"all\" ) filters ( list ): A list of filters (Default: [] ) actions ( list ): A list of actions","title":"Rule options"},{"location":"rules/#targeting-directories","text":"When targets is set to dirs , organize will work on the folders, not on files. The filters adjust their meaning automatically. For example the size filter sums up the size of all files contained in the given folder instead of returning the size of a single file. Of course other filters like exif or filecontent do not work on folders and will return an error.","title":"Targeting directories"},{"location":"rules/#templates-and-placeholders","text":"Placeholder variables are used with curly braces {var} . These variables are always available : {env} ( dict ) All your environment variables. You can access individual env vars like this: {env.MY_VARIABLE} . {path} ( pathlib.Path ) The full path to the current file / folder on the local harddrive. This is not available for remote locations - in this case use fs and fs_path . {relative_path} ( str ) the relative path of the current file in {fs} . {now} ( datetime ) The current datetime in the local timezone. {utcnow} ( datetime ) The current UTC datetime. {fs} ( FS ) The filesystem of the current location. Normally you should not need this. {fs_path} ( str ) The path of the current file / folder in related to fs . Normally you should not need this. In addition to that nearly all filters add new placeholders with information about the currently handled file / folder. Example on how to access the size and hash of a file: rules: - locations: ~/Desktop filters: - size - hash actions: - echo: \"{size} {hash}\" Note In order to use a value returned by a filter it must be listed in the filters!","title":"Templates and placeholders"},{"location":"rules/#advanced-aliases","text":"Instead of repeating the same locations / actions / filters in each and every rule you can use an alias for multiple locations which you can then reference in each rule. Aliases are a standard feature of the YAML syntax. all_my_messy_folders: &all - ~/Desktop - ~/Downloads - ~/Documents - ~/Dropbox rules: - locations: *all filters: ... actions: ... - locations: *all filters: ... actions: ... You can even use multiple folder lists: private_folders: &private - \"/path/private\" - \"~/path/private\" work_folders: &work - \"/path/work\" - \"~/My work folder\" all_folders: &all - *private - *work rules: - locations: *private filters: ... actions: ... - locations: *work filters: ... actions: ... - locations: *all filters: ... actions: ... # same as *all - locations: - *work - *private filters: ... actions: ...","title":"Advanced: Aliases"},{"location":"updating-from-v1/","text":"Updating from organize v1.x # First of all, thank you for being a long time user of organize ! I tried to keep the amount of breaking changes small but could not avoid them completely. Feel free to pin organize to v1.x, but then you're missing the party. Please open a issue on Github if you need help migrating your config file! Folders # Folders have become Locations in organize v2. folders must be renamed to locations in your config. REMOVED: The glob syntax ( /Docs/**/*.png ). See Location options . REMOVED: The exclamation mark exclude syntax ( ! ~/Desktop/exclude ). See Location options . All keys (filter names, action names, option names) now must be lowercase. Placeholders # organize v2 uses the Jinja template engine. You may need to change some of your placeholders. {basedir} is no longer available. You have to replace undocumented placeholders like this: {created.year}-{created.month:02}-{created.day:02} With this: {created.strftime('%Y-%m-%d')} If you need to left pad other numbers you can now use the following syntax: { \"{:02}\".format(your_variable) } # or { '%02d' % your_variable } Filters # filename is renamed to name . filesize is renamed to size . created no longer accepts a timezone and uses the local timezone by default. lastmodified no longer accepts a timezone and uses the local timezone by default. extension lower and upper are now functions and must be called like this: \"{extension.upper()}\" and \"{extension.lower()}\" . Actions # The copy, move and rename actions got a whole lot more powerful. You now have several conflict options and can specify exactly how a file should be renamed in case of a conflict. This means you might need to change your config to use the new parameters. copy arguments changed to support conflict resolution options. move arguments changed to support conflict resolution options. rename arguments changed to support conflict resolution options. Example: rules: - folders: ~/Desktop filters: - extension: pdf actions: - move: dest: ~/Documents/PDFs/ overwrite: false counter_seperator: \"-\" becomes (organize v2): rules: - locations: ~/Desktop filters: - extension: pdf actions: - move: dest: ~/Documents/PDFs/ on_conflict: rename_new rename_template: \"{name}-{counter}{extension}\" If you used move , copy or rename without arguments, nothing changes for you. Settings # The system_files setting has been removed. In order to include system files in your search, overwrite the default system_exclude_files with an empty list: rules: - locations: - path: ~/Desktop/ system_exclude_files: [] system_exclude_dirs: [] filters: - name: .DS_Store actions: - trash That's it. Again, feel free to open a issue if you have trouble migrating your config.","title":"Updating from organize v1.x"},{"location":"updating-from-v1/#updating-from-organize-v1x","text":"First of all, thank you for being a long time user of organize ! I tried to keep the amount of breaking changes small but could not avoid them completely. Feel free to pin organize to v1.x, but then you're missing the party. Please open a issue on Github if you need help migrating your config file!","title":"Updating from organize v1.x"},{"location":"updating-from-v1/#folders","text":"Folders have become Locations in organize v2. folders must be renamed to locations in your config. REMOVED: The glob syntax ( /Docs/**/*.png ). See Location options . REMOVED: The exclamation mark exclude syntax ( ! ~/Desktop/exclude ). See Location options . All keys (filter names, action names, option names) now must be lowercase.","title":"Folders"},{"location":"updating-from-v1/#placeholders","text":"organize v2 uses the Jinja template engine. You may need to change some of your placeholders. {basedir} is no longer available. You have to replace undocumented placeholders like this: {created.year}-{created.month:02}-{created.day:02} With this: {created.strftime('%Y-%m-%d')} If you need to left pad other numbers you can now use the following syntax: { \"{:02}\".format(your_variable) } # or { '%02d' % your_variable }","title":"Placeholders"},{"location":"updating-from-v1/#filters","text":"filename is renamed to name . filesize is renamed to size . created no longer accepts a timezone and uses the local timezone by default. lastmodified no longer accepts a timezone and uses the local timezone by default. extension lower and upper are now functions and must be called like this: \"{extension.upper()}\" and \"{extension.lower()}\" .","title":"Filters"},{"location":"updating-from-v1/#actions","text":"The copy, move and rename actions got a whole lot more powerful. You now have several conflict options and can specify exactly how a file should be renamed in case of a conflict. This means you might need to change your config to use the new parameters. copy arguments changed to support conflict resolution options. move arguments changed to support conflict resolution options. rename arguments changed to support conflict resolution options. Example: rules: - folders: ~/Desktop filters: - extension: pdf actions: - move: dest: ~/Documents/PDFs/ overwrite: false counter_seperator: \"-\" becomes (organize v2): rules: - locations: ~/Desktop filters: - extension: pdf actions: - move: dest: ~/Documents/PDFs/ on_conflict: rename_new rename_template: \"{name}-{counter}{extension}\" If you used move , copy or rename without arguments, nothing changes for you.","title":"Actions"},{"location":"updating-from-v1/#settings","text":"The system_files setting has been removed. In order to include system files in your search, overwrite the default system_exclude_files with an empty list: rules: - locations: - path: ~/Desktop/ system_exclude_files: [] system_exclude_dirs: [] filters: - name: .DS_Store actions: - trash That's it. Again, feel free to open a issue if you have trouble migrating your config.","title":"Settings"}]}